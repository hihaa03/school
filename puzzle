Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1FRk08ycvnhV-slUPqNeqfbOD44SyWJny
"""

import random
import copy
import heapq
import time

ROWS, COLS = 2, 5
MOVES = [(-1, 0), (1, 0), (0, -1), (0, 1)]
goal_state = [
    [1, 2, 3, 4, 5],
    [6, 7, 8, 9, 0]
]

def state_to_tuple(state):
    return tuple(tuple(row) for row in state)

def flatten(state):
    return [num for row in state for num in row]

def is_solvable(state):
    flat = flatten(state)
    inversion_count = 0
    for i in range(len(flat)):
        for j in range(i + 1, len(flat)):
            if flat[i] != 0 and flat[j] != 0 and flat[i] > flat[j]:
                inversion_count += 1
    return inversion_count % 2 == 0

def find_zero(state):
    for r in range(ROWS):
        for c in range(COLS):
            if state[r][c] == 0:
                return r, c
    return -1, -1

def search_puzzle_algorithm(start_state, search_type='a_star', log_moves=False):
    start_time = time.time()
    if not is_solvable(start_state):
        print("오류")
        return None, None, 0, 0

    visited = set()
    open_list = []
    best_g = {}  # 최단 경로값 기록 (g값이 더 작은 경로만 큐에 추가)

    if search_type == 'a_star':
        heapq.heappush(open_list, (manhattan_distance(start_state), 0, start_state, []))  # (f = g + h, g, state, path)
    elif search_type == 'dijkstra':
        heapq.heappush(open_list, (0, start_state, []))  # (g, state, path)
        best_g[state_to_tuple(start_state)] = 0

    while open_list:
        if search_type == 'a_star':
            f, g, state, path = heapq.heappop(open_list)
        elif search_type == 'dijkstra':
            g, state, path = heapq.heappop(open_list)

        state_key = state_to_tuple(state)

        if state_key in visited:
            continue
        visited.add(state_key)

        if state == goal_state:
            end_time = time.time()
            if log_moves:
                print("Solution Path:")
                for i, step in enumerate(path, 1):
                    print(f"{i}. {step}")
            return path, state, end_time - start_time, len(path)

        zr, zc = find_zero(state)
        for dr, dc in MOVES:
            nr, nc = zr + dr, zc + dc
            if 0 <= nr < ROWS and 0 <= nc < COLS:
                new_state = copy.deepcopy(state)
                new_state[zr][zc], new_state[nr][nc] = new_state[nr][nc], new_state[zr][zc]
                move_description = f"Move {new_state[zr][zc]} to ({zr},{zc})"

                new_state_key = state_to_tuple(new_state)
                new_g = g + 1

                if new_state_key not in best_g or new_g < best_g[new_state_key]:
                    best_g[new_state_key] = new_g
                    # A*의 경우 f = g + h를, Dijkstra는 g만 사용
                    if search_type == 'a_star':
                        heapq.heappush(open_list, (new_g + manhattan_distance(new_state), new_g, new_state, path + [move_description]))
                    elif search_type == 'dijkstra':
                        heapq.heappush(open_list, (new_g, new_state, path + [move_description]))

    return None, None, 0, 0

def generate_random_state():
    nums = list(range(10))
    random.shuffle(nums)
    return [nums[i*COLS:(i+1)*COLS] for i in range(ROWS)]

if __name__ == "__main__":
    while True:
        initial_state = generate_random_state()
        print("Initial State:")
        for row in initial_state:
            print(row)

        if is_solvable(initial_state):
            print("퍼즐 가능")
            break
        else:
            print("퍼즐 불가능")

    path_a_star, final_state_a_star, time_a_star, moves_a_star = search_puzzle_algorithm(initial_state, search_type='a_star', log_moves=False)
    if path_a_star:
        print(f"\nA* Algorithm Result:")
        print(f"Minimum Moves: {moves_a_star}")
        print(f"Execution Time: {time_a_star:.4f} seconds")

    path_dijkstra, final_state_dijkstra, time_dijkstra, moves_dijkstra = search_puzzle_algorithm(initial_state, search_type='dijkstra', log_moves=False)
    if path_dijkstra:
        print(f"\nDijkstra Algorithm Result:")
        print(f"Minimum Moves: {moves_dijkstra}")
        print(f"Execution Time: {time_dijkstra:.4f} seconds")
